==========
Kubernetes
==========

Kubernetes is an open-source system for automating deployment, scaling, and
management of containerized applications that builds on 15 years of experience
running production workflows at Google.

Thanks to :doc:`our Docker image <../deployment/containers/docker>`, managing
your CrateDB cluster with Kubernetes requires only a few steps.

This guide will assume that you already have `kubectl
<https://kubernetes.io/docs/tasks/tools/install-kubectl/>`_ and a `Kubernetes cluster
<http://kubernetes.io/docs/getting-started-guides/binary_release/>`_ ready to
go. All of the commands/templates/etc. provided should be customized to meet
your personal requirements!

.. rubric:: Table of Contents

.. contents::
   :local:

The CrateDB Template
====================

At CrateDB we are proud of our community and our user `'cedboss'
<https://github.com/cedbossneo>`_ provided us with a template to use for
Kubernetes to deploy CrateDB. Building on that draft we developed a more mature
version:

.. code-block:: yaml

    apiVersion: v1
    kind: Service
    metadata:
      name: crate-discovery
      labels:
        app: crate
    spec:
      ports:
      - port: 4200
        name: crate-web
      - port: 4300
        name: cluster
      - port: 5432
        name: postgres
      type: LoadBalancer
      selector:
        app: crate
    ---
    apiVersion: "apps/v1beta1"
    kind: StatefulSet
    metadata:
      name: crate
    spec:
      serviceName: "crate-db"
      replicas: 3
      template:
        metadata:
          labels:
            app: crate
          annotations:
            pod.alpha.kubernetes.io/initialized: "true"
        spec:
          initContainers:
          - name: init-sysctl
            image: busybox
            imagePullPolicy: IfNotPresent
            command: ["sysctl", "-w", "vm.max_map_count=262144"]
            securityContext:
              privileged: true
          containers:
          - name: crate
            image: crate:latest
            command:
              - /docker-entrypoint.sh
              - -Ccluster.name=${CLUSTER_NAME}
              - -Cdiscovery.zen.hosts_provider=srv
              - -Cdiscovery.zen.minimum_master_nodes=2
              - -Cdiscovery.srv.query=_cluster._tcp.crate-discovery.default.svc.cluster.local
              - -Cgateway.recover_after_nodes=2
              - -Cgateway.expected_nodes=${EXPECTED_NODES}
            volumeMounts:
                - mountPath: /data
                  name: data
            resources:
              limits:
                memory: 2Gi
            ports:
            - containerPort: 4200
              name: db
            - containerPort: 4300
              name: cluster
            - containerPort: 5432
              name: postgres
            env:
            # Half the available memory.
            - name: CRATE_HEAP_SIZE
              value: "1g"
            - name: EXPECTED_NODES
              value: "3"
            - name: CLUSTER_NAME
              value: "my-cratedb-cluster"
          volumes:
            - name: data
              emptyDir:
                medium: "Memory"

Init Containers
---------------

Init containers are containers that run before the main container of the pod,
and are intended to accomplish some prerequisite task before the pod can be fully
started. In this template's case, the init container sets a value for
``vm.max_map_count``, which is required for the bootstrap checks to pass.

Start CrateDB
-------------

This template utilizes the `Kubernetes StatefulSet
<https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/>`_ type
that allows you to add SRV records for node DNS discovery, as well as a graceful
shutdown when scaling. While CrateDB would also work as a stateless pod
(cattle), this way facilitates a couple of things like persistant storage and
shard migration on zero downtime upgrades. To create a new cluster based on
this template, use::

.. code-block:: sh

    kubectl create -f crate-kubernetes.yml

Find out the public IP and the services that have been created with

.. code-block:: sh

    kubectl get services

If it is acceptable that this service is exposed externally, then specifying the 
service type as ``LoadBalancer`` is sufficient. An external load balancer then 
routes to ``NodePort`` and ``ClusterIP`` services. However, if it is not acceptable
to expose the database on an external (public) IP, we recommend specifying the
type as NodePort. This means that the service is exposed on each Node's IP as
a static port. More information about service types can be found `here <https://kubernetes.io/docs/concepts/services-networking/service/>`.

Scale CrateDB
-------------

Next, you can scale your cluster by scaling the number of replicas of the
StatefulSet to the desired number of CrateDB nodes:

.. code-block:: sh

    kubectl scale statefulsets crate --replicas=4

After increasing/decreasing the number of pod replicas, CrateDB's config should
be adjusted, especially when scaling down or your cluster might disappear!
There are three important settings in this context:

::

    discovery.zen.minimum_master_nodes=2
    gateway.recover_after_nodes=2
    gateway.expected_nodes=3

The settings ``recover_after_nodes`` and ``expected_nodes`` are important for
the cluster to know the intended size and if it should recover or rather accept
the provided cluster state *on startup*. Therefore changing these values will
require a cluster restart and a misconfiguration will trigger a cluster check
to fail. However, the cluster will still continue to function properly.
``discovery.zen.minimum_master_nodes`` on the other hand influences how the
master nodes are elected, and a value greater than the number of nodes is going
to disband the cluster, whereas a too small number might lead to a split-brain
scenario - which is why it is necessary to adjust this number when scaling by
issuing

.. code-block:: psql

    SET GLOBAL PERSISTENT discovery.zen.minimum_master_nodes = 5

... where 5 is one more than half the actual number of nodes in the cluster.
Now to monitor the available pods you can use ``kubectl proxy`` which starts a
web server with log outputs and a list of the available pods.

Customize CrateDB
-----------------

In this template, CrateDB is configured using the ``-C`` parameters for the
executable. Every setting in `CrateDB's YAML config
<https://crate.io/docs/reference/configuration.html>`_ is available there and
allows for a better flexibility than passing around config files.

Storage
-------

The above example makes use of in-memory storage. This is only suggested to 
facilitate testing out of CrateDB with Kubernetes. It is not advisable to use
this form of storage for a production database because all data from this
directory will be lost if a pod is deleted. More information on this can be
found `here <kubernetes.io/docs/concepts/storage/volumes/#emptydir>`.

When you require durable storage, `persistent volumes
<https://kubernetes.io/docs/concepts/storage/persistent-volumes/>` (PV) should
be used with CrateDB. A volume is bound and mounted to each Crate pod, using
``volumeClaimTemplates`` within the StatefulSet configuration.

.. code-block:: yaml

      volumeClaimTemplates:
      - metadata:
          name: crate-persistent-storage
        spec:
          accessModes:
          - ReadWriteOnce
          resources:
            requests:
              storage: 10Gi

Each PV has a lifecycle which is independent of the pod that makes use of it.
In the event that a pod (or group of pods) is destroyed, the data will persist
on these volumes and will be reassigned to the pods when they re-spawn.

Many container hosting services offer spinning disks as default storage media,
however the performance of such volumes can be dependent on the cloud provider.
Nevertheless, replication only makes sense if the data is on separate physical
media in order to achieve high availability and to avoid potential bottlenecks
when several clusters attach the same storage. More information about
provisioning persistent volumes with a cloud provider can be found `here
<https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning>`.

You can familiarize yourself with ``Volumes`` and ``StatefulSets`` `here
<https://kubernetes.io/docs/concepts/workloads/controllers/statefulset>`_.
Volumes can be customized as required, to achieve this, the `kubernetes volume
guide <https://kubernetes.io/docs/concepts/storage/volumes/>`_ is very
helpful.

Manual Approach
===============

Create a Kubernetes 'pod', or a group of containers tied together for
administration and networking. In this case, using the CrateDB Docker image and
exposing the ports that CrateDB uses.

.. code-block:: sh

    kubectl run crate-cluster --image=crate:latest --port=4200 --port=4300 --port=5432

Expose the pod to the outside World with a specific Kubernetes service:

.. code-block:: sh

    kubectl expose deployment crate-cluster --type="LoadBalancer"

And use the following command to get the status of the service you just
created:

.. code-block:: sh

    kubectl get services crate-cluster

Scale a CrateDB pod with:

.. code-block:: sh

    kubectl scale deployment crate-cluster --replicas=3
